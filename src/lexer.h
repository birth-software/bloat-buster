#pragma once

#include <compiler.h>

#ifdef _WIN32
typedef f64 FloatLiteral;
#else
typedef f128 FloatLiteral;
#endif

typedef enum TokenId : u8
{
    TOKEN_ID_NONE,
    TOKEN_ID_EOF,

    TOKEN_ID_IDENTIFIER_START,
    TOKEN_ID_IDENTIFIER_END,
    TOKEN_ID_INTEGER_START_HEXADECIMAL_PREFIXED,
    TOKEN_ID_INTEGER_START_DECIMAL_PREFIXED,
    TOKEN_ID_INTEGER_START_OCTAL_PREFIXED,
    TOKEN_ID_INTEGER_START_BINARY_PREFIXED,
    TOKEN_ID_INTEGER_START_DECIMAL_INFERRED,
    TOKEN_ID_INTEGER_END,
    TOKEN_ID_FLOAT_START,
    TOKEN_ID_FLOAT_END,
    TOKEN_ID_STRING_LITERAL_START,
    TOKEN_ID_STRING_LITERAL_END,

    TOKEN_ID_CHARACTER_LITERAL,

    TOKEN_ID_KEYWORD_TYPE_INTEGER,
    TOKEN_ID_KEYWORD_TYPE_FLOAT,

    TOKEN_ID_KEYWORD_TYPE,
    TOKEN_ID_KEYWORD_TYPE_VOID,
    TOKEN_ID_KEYWORD_TYPE_NORETURN,
    TOKEN_ID_KEYWORD_TYPE_ENUM,
    TOKEN_ID_KEYWORD_TYPE_STRUCT,
    TOKEN_ID_KEYWORD_TYPE_BITS,
    TOKEN_ID_KEYWORD_TYPE_UNION,
    TOKEN_ID_KEYWORD_TYPE_FN,
    TOKEN_ID_KEYWORD_TYPE_ALIAS,
    TOKEN_ID_KEYWORD_TYPE_VECTOR,
    TOKEN_ID_KEYWORD_TYPE_ENUM_ARRAY,
    TOKEN_ID_KEYWORD_TYPE_OPAQUE,

    TOKEN_ID_KEYWORD_STATEMENT_UNDERSCORE,
    TOKEN_ID_KEYWORD_STATEMENT_RETURN,
    TOKEN_ID_KEYWORD_STATEMENT_IF,
    TOKEN_ID_KEYWORD_STATEMENT_WHEN,
    TOKEN_ID_KEYWORD_STATEMENT_FOR,
    TOKEN_ID_KEYWORD_STATEMENT_WHILE,
    TOKEN_ID_KEYWORD_STATEMENT_SWITCH,
    TOKEN_ID_KEYWORD_STATEMENT_BREAK,
    TOKEN_ID_KEYWORD_STATEMENT_CONTINUE,
    TOKEN_ID_KEYWORD_STATEMENT_UNREACHABLE,
    TOKEN_ID_KEYWORD_STATEMENT_ELSE,

    TOKEN_ID_KEYWORD_VALUE_UNDEFINED,
    TOKEN_ID_KEYWORD_VALUE_ZERO,

    TOKEN_ID_KEYWORD_OPERATOR_AND,
    TOKEN_ID_KEYWORD_OPERATOR_OR,
    TOKEN_ID_KEYWORD_OPERATOR_AND_SHORTCIRCUIT,
    TOKEN_ID_KEYWORD_OPERATOR_OR_SHORTCIRCUIT,

    TOKEN_ID_ASSIGN,
    TOKEN_ID_COMPARE_EQUAL,
    TOKEN_ID_SWITCH_CASE,

    TOKEN_ID_EXCLAMATION_DOWN,
    TOKEN_ID_COMPARE_NOT_EQUAL,

    TOKEN_ID_COMPARE_LESS,
    TOKEN_ID_COMPARE_LESS_EQUAL,
    TOKEN_ID_SHIFT_LEFT,
    TOKEN_ID_SHIFT_LEFT_ASSIGN,

    TOKEN_ID_COMPARE_GREATER,
    TOKEN_ID_COMPARE_GREATER_EQUAL,
    TOKEN_ID_SHIFT_RIGHT,
    TOKEN_ID_SHIFT_RIGHT_ASSIGN,

    TOKEN_ID_PLUS,
    TOKEN_ID_ADD_ASSIGN,

    TOKEN_ID_DASH,
    TOKEN_ID_SUB_ASSIGN,

    TOKEN_ID_ASTERISK,
    TOKEN_ID_MUL_ASSIGN,

    TOKEN_ID_FORWARD_SLASH,
    TOKEN_ID_DIV_ASSIGN,

    TOKEN_ID_PERCENTAGE,
    TOKEN_ID_REM_ASSIGN,

    TOKEN_ID_AMPERSAND,
    TOKEN_ID_BITWISE_AND_ASSIGN,

    TOKEN_ID_BAR,
    TOKEN_ID_BITWISE_OR_ASSIGN,

    TOKEN_ID_CARET,
    TOKEN_ID_BITWISE_XOR_ASSIGN,

    TOKEN_ID_DOT,
    TOKEN_ID_POINTER_DEREFERENCE,
    TOKEN_ID_OPTIONAL_DEREFERENCE,
    TOKEN_ID_DOUBLE_DOT,
    TOKEN_ID_TRIPLE_DOT,

    TOKEN_ID_LEFT_PARENTHESIS,
    TOKEN_ID_RIGHT_PARENTHESIS,
    TOKEN_ID_LEFT_BRACE,
    TOKEN_ID_RIGHT_BRACE,
    TOKEN_ID_LEFT_BRACKET,
    TOKEN_ID_RIGHT_BRACKET,

    TOKEN_ID_COMMA,
    TOKEN_ID_SEMICOLON,
    TOKEN_ID_COLON,
    TOKEN_ID_QUESTION,
    TOKEN_ID_AT,
    TOKEN_ID_BACKTICK,
    TOKEN_ID_BACKSLASH,
    TOKEN_ID_HASH,
    TOKEN_ID_DOLLAR,
    TOKEN_ID_TILDE,

    // These are 0-based
    TOKEN_ID_LINE_BYTE_OFFSET,
    TOKEN_ID_LINE_NUMBER_OFFSET,

    TOKEN_ID_ERROR_LINE_NUMBER_TOO_HIGH,
    TOKEN_ID_ERROR_COLUMN_NUMBER_TOO_HIGH,
    TOKEN_ID_ERROR_PRIMITIVE_TYPE_0_BIT_COUNT,
    TOKEN_ID_ERROR_PRIMITIVE_TYPE_UNKNOWN_BIT_COUNT,
    TOKEN_ID_ERROR_STRING_LITERAL_EOF_NO_DOUBLE_QUOTE,
    TOKEN_ID_ERROR_CHARACTER_LITERAL_EMPTY,
    TOKEN_ID_ERROR_CHARACTER_LITERAL_BADLY_TERMINATED,
    TOKEN_ID_ERROR_NOT_SUPPORTED_X_ASCII_OR_UNICODE,
    TOKEN_ID_ERROR_NON_PRINTABLE_ASCII,
    TOKEN_ID_ERROR_FOUND_DEL,
    TOKEN_ID_ERROR_IDENTIFIER_TOO_LONG,
} TokenId;

STRUCT(TokenIntegerType)
{
    u64 bit_count;
    bool is_signed;
};

UNION(TokenContent)
{
    str string;
    u128 integer;
    FloatLiteral float_literal;
    TokenIntegerType integer_type;
};

STRUCT(Token)
{
    u32 offset:24;
    TokenId id;
};
static_assert(sizeof(Token) == sizeof(u32));

typedef u32 TokenIndex;

STRUCT(TokenList)
{
    Token* pointer;
    u64 length;
};

STRUCT(IntegerParsing)
{
    u64 value;
    u64 i;
};

TokenList lex(CompileUnit* unit, File* file);

#if BB_INCLUDE_TESTS
bool lexer_tests(TestArguments* restrict arguments);
str token_list_to_string(Arena* arena, TokenList list);
#endif
