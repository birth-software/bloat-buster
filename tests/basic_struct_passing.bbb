CallingConvention = enum
{
    c,
}

InlineBehavior = enum
{
    default = 0,
    always_inline = 1,
    no_inline = 2,
    inline_hint = 3,
}

FunctionAttributes = struct
{
    inline_behavior: InlineBehavior,
    naked: u1,
}

Type = struct;

TypeId = enum
{
    void,
    noreturn,
    forward_declaration,
    integer,
    function,
    pointer,
    array,
    enum,
    struct,
    bits,
    alias,
    union,
    unresolved,
    vector,
    floating_point,
    enum_array,
    opaque,
}

TypeInteger = struct
{
    bit_count: u32,
    signed: u1,
}

TypePointer = struct
{
    element_type: &Type,
    next: &Type,
}

AbiRegisterCountSystemV = struct
{
    gpr: u32,
    sse: u32,
};

AbiRegisterCount = union
{
    system_v: AbiRegisterCountSystemV,
};

AbiInformation = struct
{
    foo: u32,
}

TypeFunction = struct
{
    semantic_return_type: &Type,
    semantic_argument_types: []&Type,
    calling_convention: CallingConvention,
    is_variable_arguments: u1,

    abi_argument_types: []&Type,
    abi_return_type: &Type,
    available_registers: AbiRegisterCount,
    argument_abis: []AbiInformation,
    return_abi: AbiInformation,
}

TypeContent = union
{
    integer: TypeInteger,
    function: TypeFunction,
    pointer: TypePointer,
}

Type = struct
{
    content: TypeContent,
    id: TypeId,
    name: []u8,
    next: &Type,
}

give_me_string = fn () []u8
{
    return "foooo";
}

get_type = fn (src: &Type, type: Type) &Type
{
    src.& = type;
    return src;
}

require = fn (ok: u1) void
{
    if (!ok) #trap();
}

[export] main = fn [cc(c)] () s32
{
    >buffer: Type = undefined;
    >pointer = &buffer;
    require(pointer == &buffer);
    require(pointer != zero);
    >result = get_type(pointer, {
        .content = {
            .pointer = {
                .element_type = pointer,
                zero,
            },
        },
        .id = .pointer,
        .name = give_me_string(),
        zero,
    });

    require(pointer != zero);
    require(pointer == &buffer);
    require(buffer.content.pointer.element_type == pointer);
    require(buffer.id == .pointer);

    return 0;
}
